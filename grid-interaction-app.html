<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Grid Marking Practice</title>
    <!-- PDF.js Library (using CDN) -->
    <script src="//mozilla.github.io/pdf.js/build/pdf.mjs" type="module"></script>

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        #controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #pdf-container {
            position: relative;
            /* Size will be set by canvas */
            width: fit-content;
            max-width: 90vw; /* Limit max width */
            margin: 0 auto; /* Center the container */
            border: 1px solid #ccc;
            background-color: #eee; /* Background while loading */
            min-height: 100px; /* Placeholder height */
        }

        #pdf-canvas {
            display: block; /* Remove extra space */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio via JS */
        }

        #interactive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            /* Grid columns/rows will be set by JS */
            cursor: crosshair;
            /* Optional: makes grid lines visible for debugging */
            /* background-color: rgba(255, 0, 0, 0.05); */
            /* border: 2px solid red; */ /* Debugging border */
        }

        .grid-cell {
            /* Optional: makes cell boundaries visible */
            /* border: 1px solid rgba(0, 0, 255, 0.1); */
            position: relative; /* Needed for absolute positioning of dots */
            box-sizing: border-box; /* Include border in size */
            /* background-color: rgba(0, 255, 0, 0.1); */ /* Debug cell background */
        }

        .grid-cell:hover {
             background-color: rgba(200, 200, 255, 0.3); /* Highlight on hover */
        }

        .dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px; /* Size of the dot */
            height: 10px; /* Size of the dot */
            border-radius: 50%;
            transform: translate(-50%, -50%); /* Center the dot */
            pointer-events: none; /* Don't let dots interfere with clicks */
            box-shadow: 0 0 2px rgba(0,0,0,0.5); /* Slight shadow */
        }

        .start-dot {
            background-color: limegreen; /* Brighter green */
        }

        .path-dot {
            background-color: dodgerblue; /* Standard blue */
        }

        #loading-message {
            display: none;
            margin-top: 10px;
            color: #555;
        }
         #error-message {
            display: none;
            margin-top: 10px;
            color: red;
            font-weight: bold;
        }


        #instructions {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>PDF Grid Marking Tool</h1>

    <div id="controls">
        <label for="pdfLoader">Load Grid PDF:</label>
        <input type="file" id="pdfLoader" accept=".pdf">
        <button id="resetButton">Reset Grid</button>
    </div>

     <div id="loading-message">Loading and rendering PDF...</div>
     <div id="error-message"></div>

    <div id="pdf-container">
        <canvas id="pdf-canvas"></canvas>
        <div id="interactive-overlay">
            <!-- Grid cells will be generated here by JavaScript -->
        </div>
    </div>

    <div id="instructions">
       <p>1. Load your grid PDF (ensure the grid is on the first page).</p>
       <p>2. Click in a cell in the **top row** to set a green start point for that column. The start point will be copied down the column.</p>
       <p>3. Click other cells in the **top row** (within the same column's square) to draw a blue path originating from the start point.</p>
       <p>4. Use the Reset button to clear everything.</p>
       <p><i>Note: Assumes the grid image within the PDF has 13 rows and 8 columns of squares. Alignment depends on the PDF structure.</i></p>
    </div>

    <script type="module"> // Use type="module" to allow import
        // Import PDF.js - Ensure the path matches the script tag src
        const pdfjsLib = window['pdfjs-dist/build/pdf'];
        // Specify the worker source explicitly for broader compatibility
        pdfjsLib.GlobalWorkerOptions.workerSrc = '//mozilla.github.io/pdf.js/build/pdf.worker.mjs';

        const pdfLoader = document.getElementById('pdfLoader');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const overlay = document.getElementById('interactive-overlay');
        const resetButton = document.getElementById('resetButton');
        const instructions = document.getElementById('instructions');
        const pdfContainer = document.getElementById('pdf-container');
        const loadingMessage = document.getElementById('loading-message');
        const errorMessage = document.getElementById('error-message');

        // --- Configuration ---
        const GRID_ROWS = 13;
        const GRID_COLS = 8;
        const MAX_RENDER_WIDTH = 800; // Max width in pixels to render the PDF canvas
        // ---------------------

        let startPoints = new Array(GRID_COLS).fill(null);
        let paths = Array.from({ length: GRID_COLS }, () => []);
        let currentPdfDoc = null; // Store the loaded PDF document


        function createOverlayGrid(canvasWidth, canvasHeight) {
            console.log(`Creating overlay grid for canvas size: ${canvasWidth}x${canvasHeight}`);
            overlay.innerHTML = ''; // Clear previous grid
            startPoints.fill(null);
            paths = Array.from({ length: GRID_COLS }, () => []);

             // Ensure overlay matches canvas size explicitly
             overlay.style.width = `${canvasWidth}px`;
             overlay.style.height = `${canvasHeight}px`;
             pdfContainer.style.width = `${canvasWidth}px`; // Adjust container size
             pdfContainer.style.height = `${canvasHeight}px`;

            // Set overlay grid dimensions
            overlay.style.gridTemplateRows = `repeat(${GRID_ROWS}, 1fr)`;
            overlay.style.gridTemplateColumns = `repeat(${GRID_COLS}, 1fr)`;

            // Create individual grid cells
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);
                    overlay.appendChild(cell);
                }
            }
             console.log(`Created ${GRID_ROWS}x${GRID_COLS} grid overlay.`);
             overlay.style.display = 'grid'; // Make overlay visible
        }

        function handleCellClick(event) {
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (isNaN(row) || isNaN(col)) return;

            console.log(`Clicked cell: Row ${row}, Col ${col}`);

            if (row === 0) { // Interaction only starts in the first row
                if (startPoints[col] === null) {
                    // Set Start Point
                    console.log(`Setting start point for column ${col}`);
                    addDot(cell, 'start');
                    startPoints[col] = { row, col };
                    replicateStartPoint(col);
                } else {
                     // Add to Path
                    if (cell === getCellElement(startPoints[col].row, startPoints[col].col)) {
                         console.log(`Clicked on existing start point cell in Col ${col}, ignoring for path.`);
                         return;
                     }
                     const existingPathDots = cell.querySelectorAll('.path-dot');
                     if(existingPathDots.length === 0) {
                        console.log(`Adding path point in column ${col} at Row ${row}`);
                        addDot(cell, 'path');
                        paths[col].push({ row, col });
                     } else {
                         console.log(`Path dot already exists in this cell (Col ${col}), ignoring.`);
                     }
                }
            } else {
                console.log(`Clicked outside first row (Row ${row}), no action.`);
            }
        }

         function addDot(cellElement, type) {
            if (!cellElement) return;
            const existingDots = cellElement.querySelectorAll(`.dot.${type}-dot`);
             if (existingDots.length > 0 && type !== 'path') { // Allow multiple path dots potentially, but only one start
                 console.log(`Start dot already exists in cell R${cellElement.dataset.row} C${cellElement.dataset.col}. Skipping.`);
                return;
             }

            const dot = document.createElement('div');
            dot.classList.add('dot', `${type}-dot`);
            cellElement.appendChild(dot);
            // console.log(`Added ${type} dot to cell R${cellElement.dataset.row} C${cellElement.dataset.col}`);
        }

        function replicateStartPoint(colIndex) {
            // console.log(`Replicating start point down column ${colIndex}`);
            for (let r = 1; r < GRID_ROWS; r++) {
                const targetCell = getCellElement(r, colIndex);
                if (targetCell) {
                     addDot(targetCell, 'start');
                } else {
                    // console.warn(`Could not find cell for replication at Row ${r}, Col ${colIndex}`);
                }
            }
        }

        function getCellElement(row, col) {
           return overlay.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
        }

        function resetGrid() {
            console.log("Resetting grid.");
            startPoints.fill(null);
            paths = Array.from({ length: GRID_COLS }, () => []);
            const allDots = overlay.querySelectorAll('.dot');
            allDots.forEach(dot => dot.remove());
        }

        function displayError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            loadingMessage.style.display = 'none';
             pdfCanvas.style.display = 'none';
             overlay.style.display = 'none';
        }

        // --- PDF Loading and Rendering ---
        async function loadAndRenderPdf(file) {
            resetGrid(); // Clear previous state
            pdfCanvas.style.display = 'none'; // Hide canvas during load
            overlay.style.display = 'none'; // Hide overlay
            errorMessage.style.display = 'none'; // Hide old errors
            loadingMessage.style.display = 'block'; // Show loading message
            currentPdfDoc = null; // Clear previous doc reference

            const reader = new FileReader();

            reader.onload = async (e) => {
                const typedarray = new Uint8Array(e.target.result);
                try {
                    const loadingTask = pdfjsLib.getDocument({ data: typedarray });
                    currentPdfDoc = await loadingTask.promise;
                    console.log('PDF loaded');

                    // Fetch the first page
                    const pageNumber = 1;
                    const page = await currentPdfDoc.getPage(pageNumber);
                    console.log('Page 1 loaded');

                    // --- Calculate scale and viewport ---
                    const desiredWidth = MAX_RENDER_WIDTH;
                    const viewportDefault = page.getViewport({ scale: 1 });
                    const scale = desiredWidth / viewportDefault.width;
                    const viewport = page.getViewport({ scale: scale });
                    console.log(`Calculated scale: ${scale.toFixed(3)} for desired width ${desiredWidth}`);
                    console.log(`Viewport dimensions: ${viewport.width}x${viewport.height}`);


                    // Prepare canvas using PDF page dimensions
                    const context = pdfCanvas.getContext('2d');
                    pdfCanvas.height = viewport.height;
                    pdfCanvas.width = viewport.width;
                    pdfCanvas.style.display = 'block'; // Show canvas now

                     // Adjust container size AFTER canvas size is set
                    pdfContainer.style.width = `${viewport.width}px`;
                    pdfContainer.style.height = `${viewport.height}px`;


                    // Render PDF page into canvas context
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport
                    };
                    const renderTask = page.render(renderContext);
                    await renderTask.promise;
                    console.log('Page rendered');

                    // --- Create the interactive grid OVER the rendered canvas ---
                    createOverlayGrid(viewport.width, viewport.height);

                    loadingMessage.style.display = 'none'; // Hide loading message
                    instructions.style.display = 'block'; // Show instructions


                } catch (reason) {
                    // PDF loading/rendering error
                    console.error('Error loading or rendering PDF:', reason);
                    displayError(`Error: Could not load or render PDF. ${reason.message || reason}`);
                    currentPdfDoc = null; // Ensure reset
                }
            };

             reader.onerror = (e) => {
                 console.error("FileReader error:", e);
                 displayError("Error reading the PDF file.");
                 loadingMessage.style.display = 'none';
             }

            reader.readAsArrayBuffer(file);
        }


        // --- Event Listeners ---
        pdfLoader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type === "application/pdf") {
                loadAndRenderPdf(file);
            } else if (file) {
                 displayError("Please select a valid PDF file.");
                 resetGrid();
                 pdfCanvas.style.display = 'none';
                 overlay.style.display = 'none';
                 instructions.style.display = 'none';
            }
        });

        resetButton.addEventListener('click', resetGrid);

         // Initial state
         instructions.style.display = 'none';

    </script>

</body>
</html>