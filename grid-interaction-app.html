<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Marking Practice</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        #controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #grid-container {
            position: relative;
            /* Set initial size or let it be determined by image */
            width: fit-content;
            max-width: 90vw; /* Limit max width */
            border: 1px solid #ccc;
        }

        #grid-image {
            display: block; /* Remove extra space below image */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
            opacity: 0.7; /* Make background slightly transparent to see overlay better if needed */
        }

        #interactive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            /* Grid columns/rows will be set by JS */
            cursor: crosshair;
             /* Optional: makes grid lines visible for debugging */
            /* background-color: rgba(255, 0, 0, 0.1); */
        }

        .grid-cell {
            /* Optional: makes cell boundaries visible */
            /* border: 1px solid rgba(0, 0, 255, 0.2); */
            position: relative; /* Needed for absolute positioning of dots */
            box-sizing: border-box; /* Include border in size */
        }

        .grid-cell:hover {
             background-color: rgba(200, 200, 255, 0.3); /* Highlight on hover */
        }

        .dot {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px; /* Size of the dot */
            height: 10px; /* Size of the dot */
            border-radius: 50%;
            transform: translate(-50%, -50%); /* Center the dot */
            pointer-events: none; /* Don't let dots interfere with clicks */
        }

        .start-dot {
            background-color: green;
        }

        .path-dot {
            background-color: blue; /* Color for path points */
        }

        #instructions {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>Grid Marking Tool</h1>

    <div id="controls">
        <label for="imageLoader">Load Grid Image:</label>
        <input type="file" id="imageLoader" accept="image/*">
        <button id="resetButton">Reset Grid</button>
    </div>

    <div id="grid-container">
        <img id="grid-image" src="" alt="Load an image using the button above">
        <div id="interactive-overlay">
            <!-- Grid cells will be generated here by JavaScript -->
        </div>
    </div>

    <div id="instructions">
       <p>1. Load your grid image (like the example provided).</p>
       <p>2. Click in a cell in the **top row** to set a green start point for that column. The start point will be copied down the column.</p>
       <p>3. Click other cells in the **top row** (within the same column's square) to draw a blue path originating from the start point.</p>
       <p>4. Use the Reset button to clear everything.</p>
       <p><i>Note: Assumes the grid image has 13 rows and 8 columns of squares.</i></p>
    </div>


    <script>
        const imageLoader = document.getElementById('imageLoader');
        const gridImage = document.getElementById('grid-image');
        const overlay = document.getElementById('interactive-overlay');
        const resetButton = document.getElementById('resetButton');
        const instructions = document.getElementById('instructions');

        // --- Configuration ---
        // IMPORTANT: Adjust these if your grid image has a different layout
        const GRID_ROWS = 13;
        const GRID_COLS = 8;
        // ---------------------

        let startPoints = new Array(GRID_COLS).fill(null); // Stores {row, col} of start point for each column
        let paths = Array.from({ length: GRID_COLS }, () => []); // Stores array of {row, col} for paths in first row

        function createImageGrid() {
            // Clear previous grid and state
            overlay.innerHTML = '';
            startPoints.fill(null);
            paths = Array.from({ length: GRID_COLS }, () => []);

            // Set overlay grid dimensions based on config
            overlay.style.gridTemplateRows = `repeat(${GRID_ROWS}, 1fr)`;
            overlay.style.gridTemplateColumns = `repeat(${GRID_COLS}, 1fr)`;

            // Create individual grid cells
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);
                    overlay.appendChild(cell);
                }
            }
             console.log(`Created ${GRID_ROWS}x${GRID_COLS} grid overlay.`);
        }

        function handleCellClick(event) {
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (isNaN(row) || isNaN(col)) return; // Click wasn't on a cell

            console.log(`Clicked cell: Row ${row}, Col ${col}`);

            if (row === 0) { // Interaction only starts in the first row
                if (startPoints[col] === null) {
                    // --- Set Start Point ---
                    console.log(`Setting start point for column ${col}`);
                    addDot(cell, 'start');
                    startPoints[col] = { row, col }; // Record start point
                    replicateStartPoint(col); // Replicate down the column
                } else {
                     // --- Add to Path ---
                     // Check if click is on the start point cell itself - ignore if so
                    if (cell === getCellElement(startPoints[col].row, startPoints[col].col)) {
                         console.log(`Clicked on existing start point cell in Col ${col}, ignoring for path.`);
                         return;
                     }
                     // Avoid adding multiple path dots to the *exact same* cell
                     const existingPathDots = cell.querySelectorAll('.path-dot');
                     if(existingPathDots.length === 0) {
                        console.log(`Adding path point in column ${col} at Row ${row}`);
                        addDot(cell, 'path');
                        paths[col].push({ row, col }); // Record path point
                     } else {
                         console.log(`Path dot already exists in this cell (Col ${col}), ignoring.`);
                     }
                }
            } else {
                // Clicks outside the first row do nothing (other than display replicated start points)
                console.log(`Clicked outside first row (Row ${row}), no action.`);
            }
        }

        function addDot(cellElement, type) {
            if (!cellElement) return;
            // Prevent adding multiple dots of the same type to the same cell
            const existingDots = cellElement.querySelectorAll(`.dot.${type}-dot`);
             if (existingDots.length > 0) {
                 console.log(`Dot of type ${type} already exists in cell R${cellElement.dataset.row} C${cellElement.dataset.col}. Skipping.`);
                return;
             }

            const dot = document.createElement('div');
            dot.classList.add('dot', `${type}-dot`);
            cellElement.appendChild(dot);
            console.log(`Added ${type} dot to cell R${cellElement.dataset.row} C${cellElement.dataset.col}`);

        }

        function replicateStartPoint(colIndex) {
            console.log(`Replicating start point down column ${colIndex}`);
            for (let r = 1; r < GRID_ROWS; r++) { // Start from row 1
                const targetCell = getCellElement(r, colIndex);
                if (targetCell) {
                     addDot(targetCell, 'start');
                } else {
                    console.warn(`Could not find cell for replication at Row ${r}, Col ${colIndex}`);
                }
            }
        }

        function getCellElement(row, col) {
           return overlay.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
        }

        function resetGrid() {
            console.log("Resetting grid.");
            // Clear state arrays
            startPoints.fill(null);
             paths = Array.from({ length: GRID_COLS }, () => []);

            // Remove all dots from the DOM
            const allDots = overlay.querySelectorAll('.dot');
            allDots.forEach(dot => dot.remove());

             // Optional: Clear the image preview if desired
             // gridImage.src = '';
             // overlay.innerHTML = ''; // Or just recreate grid if image persists
             // If you want to keep the image but just clear dots, the dot removal is sufficient.
        }

        // --- Event Listeners ---
        imageLoader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    gridImage.onload = () => {
                        console.log(`Image loaded: ${gridImage.naturalWidth}x${gridImage.naturalHeight}`);
                         // Update container size to match image AFTER it loads
                        // Note: overlay uses 100% width/height of container
                        createImageGrid(); // Create the grid overlay *after* image is loaded
                         instructions.style.display = 'block'; // Show instructions
                    }
                    gridImage.onerror = () => {
                         console.error("Error loading image.");
                         alert("Error loading image file.");
                         instructions.style.display = 'none';
                     }
                    gridImage.src = e.target.result;
                }
                reader.readAsDataURL(file);
            }
        });

        resetButton.addEventListener('click', resetGrid);

         // Initial state
         instructions.style.display = 'none'; // Hide instructions until image loaded

    </script>

</body>
</html>